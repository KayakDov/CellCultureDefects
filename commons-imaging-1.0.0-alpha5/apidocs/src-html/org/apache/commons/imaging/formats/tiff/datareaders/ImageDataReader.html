<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.commons.imaging.formats.tiff.datareaders, class: ImageDataReader">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="source-line-no">003</span><span id="line-3"> * contributor license agreements.  See the NOTICE file distributed with</span>
<span class="source-line-no">004</span><span id="line-4"> * this work for additional information regarding copyright ownership.</span>
<span class="source-line-no">005</span><span id="line-5"> * The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="source-line-no">006</span><span id="line-6"> * (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">007</span><span id="line-7"> * the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">010</span><span id="line-10"> *</span>
<span class="source-line-no">011</span><span id="line-11"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">012</span><span id="line-12"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">013</span><span id="line-13"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">014</span><span id="line-14"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">015</span><span id="line-15"> * limitations under the License.</span>
<span class="source-line-no">016</span><span id="line-16"> */</span>
<span class="source-line-no">017</span><span id="line-17">package org.apache.commons.imaging.formats.tiff.datareaders;</span>
<span class="source-line-no">018</span><span id="line-18"></span>
<span class="source-line-no">019</span><span id="line-19">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_CCITT_1D;</span>
<span class="source-line-no">020</span><span id="line-20">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_CCITT_GROUP_3;</span>
<span class="source-line-no">021</span><span id="line-21">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_CCITT_GROUP_4;</span>
<span class="source-line-no">022</span><span id="line-22">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_DEFLATE_ADOBE;</span>
<span class="source-line-no">023</span><span id="line-23">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_DEFLATE_PKZIP;</span>
<span class="source-line-no">024</span><span id="line-24">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_LZW;</span>
<span class="source-line-no">025</span><span id="line-25">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_PACKBITS;</span>
<span class="source-line-no">026</span><span id="line-26">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_COMPRESSION_UNCOMPRESSED;</span>
<span class="source-line-no">027</span><span id="line-27">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_FLAG_T4_OPTIONS_2D;</span>
<span class="source-line-no">028</span><span id="line-28">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_FLAG_T4_OPTIONS_FILL;</span>
<span class="source-line-no">029</span><span id="line-29">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_FLAG_T4_OPTIONS_UNCOMPRESSED_MODE;</span>
<span class="source-line-no">030</span><span id="line-30">import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_FLAG_T6_OPTIONS_UNCOMPRESSED_MODE;</span>
<span class="source-line-no">031</span><span id="line-31"></span>
<span class="source-line-no">032</span><span id="line-32">import java.awt.Rectangle;</span>
<span class="source-line-no">033</span><span id="line-33">import java.io.ByteArrayInputStream;</span>
<span class="source-line-no">034</span><span id="line-34">import java.io.IOException;</span>
<span class="source-line-no">035</span><span id="line-35">import java.io.InputStream;</span>
<span class="source-line-no">036</span><span id="line-36">import java.nio.ByteOrder;</span>
<span class="source-line-no">037</span><span id="line-37">import java.util.Arrays;</span>
<span class="source-line-no">038</span><span id="line-38"></span>
<span class="source-line-no">039</span><span id="line-39">import org.apache.commons.imaging.ImagingException;</span>
<span class="source-line-no">040</span><span id="line-40">import org.apache.commons.imaging.common.Allocator;</span>
<span class="source-line-no">041</span><span id="line-41">import org.apache.commons.imaging.common.ImageBuilder;</span>
<span class="source-line-no">042</span><span id="line-42">import org.apache.commons.imaging.common.PackBits;</span>
<span class="source-line-no">043</span><span id="line-43">import org.apache.commons.imaging.common.ZlibDeflate;</span>
<span class="source-line-no">044</span><span id="line-44">import org.apache.commons.imaging.formats.tiff.TiffDirectory;</span>
<span class="source-line-no">045</span><span id="line-45">import org.apache.commons.imaging.formats.tiff.TiffField;</span>
<span class="source-line-no">046</span><span id="line-46">import org.apache.commons.imaging.formats.tiff.TiffRasterData;</span>
<span class="source-line-no">047</span><span id="line-47">import org.apache.commons.imaging.formats.tiff.constants.TiffPlanarConfiguration;</span>
<span class="source-line-no">048</span><span id="line-48">import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;</span>
<span class="source-line-no">049</span><span id="line-49">import org.apache.commons.imaging.formats.tiff.itu_t4.T4AndT6Compression;</span>
<span class="source-line-no">050</span><span id="line-50">import org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter;</span>
<span class="source-line-no">051</span><span id="line-51">import org.apache.commons.imaging.mylzw.MyLzwDecompressor;</span>
<span class="source-line-no">052</span><span id="line-52"></span>
<span class="source-line-no">053</span><span id="line-53">/**</span>
<span class="source-line-no">054</span><span id="line-54"> * Defines the base class for the TIFF file reader classes. The TIFF format defines two broad organizations for image pixel storage: strips and tiles. This</span>
<span class="source-line-no">055</span><span id="line-55"> * class defines common elements for both representations.</span>
<span class="source-line-no">056</span><span id="line-56"> * &lt;p&gt;</span>
<span class="source-line-no">057</span><span id="line-57"> * &lt;strong&gt;The TIFF Floating-Point Formats &lt;/strong&gt;</span>
<span class="source-line-no">058</span><span id="line-58"> * &lt;p&gt;</span>
<span class="source-line-no">059</span><span id="line-59"> * In addition to providing images, TIFF files can supply data in the form of numerical values. As of March 2020 the Commons Imaging library was extended to</span>
<span class="source-line-no">060</span><span id="line-60"> * support some floating-point data formats.</span>
<span class="source-line-no">061</span><span id="line-61"> * &lt;p&gt;</span>
<span class="source-line-no">062</span><span id="line-62"> * Unfortunately, the TIFF floating-point format allows for a lot of different variations. At this time, only the most widely used of these are supported. When</span>
<span class="source-line-no">063</span><span id="line-63"> * this code was written, only a small set of test data products were available. Thus it is likely that developers will wish to extend the range of</span>
<span class="source-line-no">064</span><span id="line-64"> * floating-point data that can be processed as additional test data become available. When implementing extensions to this logic, developers are reminded that</span>
<span class="source-line-no">065</span><span id="line-65"> * image processing requires the handling of literally millions of pixels, so attention to performance is essential to a successful implementation (please see</span>
<span class="source-line-no">066</span><span id="line-66"> * the notes in {@link DataReaderStrips} for more information).</span>
<span class="source-line-no">067</span><span id="line-67"> * &lt;p&gt;</span>
<span class="source-line-no">068</span><span id="line-68"> * The TIFF floating-point specification is poorly documented. So these notes are included to provide clarification on at least some aspects of the format. Some</span>
<span class="source-line-no">069</span><span id="line-69"> * documentation and C-code examples are available in "TIFF Technical Note 3, April 8, 2005)".</span>
<span class="source-line-no">070</span><span id="line-70"> * &lt;p&gt;</span>
<span class="source-line-no">071</span><span id="line-71"> * &lt;strong&gt;The Predictor==3 Case&lt;/strong&gt;</span>
<span class="source-line-no">072</span><span id="line-72"> * &lt;p&gt;</span>
<span class="source-line-no">073</span><span id="line-73"> * TIFF specifies an extension for a predictor that is intended to improve data compression ratios for floating-point values. This predictor is specified using</span>
<span class="source-line-no">074</span><span id="line-74"> * the TIFF predictor TAG with a value of 3 (see TIFF Technical Note 3). Consider a 4-byte floating point value given in IEEE-754 format. Let f3 be the</span>
<span class="source-line-no">075</span><span id="line-75"> * high-order byte, with f2 the next highest, followed by f1, and f0 for the low-order byte. This designation should not be confused with the in-memory layout</span>
<span class="source-line-no">076</span><span id="line-76"> * of the bytes (little-endian versus big-endian), but rather their numerical values. The sign bit and upper 7 bits of the exponent are given in the high-order</span>
<span class="source-line-no">077</span><span id="line-77"> * byte, followed by the one remaining exponent bit and the mantissa in the lower-order bytes.</span>
<span class="source-line-no">078</span><span id="line-78"> * &lt;p&gt;</span>
<span class="source-line-no">079</span><span id="line-79"> * In many real-valued raster data sets, the sign and magnitude (exponent) of the values change slowly. But the bits in the mantissa vary rapidly in a</span>
<span class="source-line-no">080</span><span id="line-80"> * semi-random manner. The information entropy in the mantissa tends to increase in the lowest ordered bytes. Thus, the high-order bytes have more redundancy</span>
<span class="source-line-no">081</span><span id="line-81"> * than the low-order bytes and can compress more efficiently. To exploit this, the TIFF format splits the bytes into groups based on their order-of-magnitude.</span>
<span class="source-line-no">082</span><span id="line-82"> * This splitting process takes place on a ROW-BY-ROW basis (note the emphasis, this point is not clearly documented in the spec). For example, for a row of</span>
<span class="source-line-no">083</span><span id="line-83"> * length 3 pixels -- A, B, and C -- the data for two rows would be given as shown below (again, ignoring endian issues):</span>
<span class="source-line-no">084</span><span id="line-84"> *</span>
<span class="source-line-no">085</span><span id="line-85"> * &lt;pre&gt;</span>
<span class="source-line-no">086</span><span id="line-86"> *   Original:</span>
<span class="source-line-no">087</span><span id="line-87"> *      A3 A2 A1 A0   B3 B2 B1 B0   C3 C2 C1 C0</span>
<span class="source-line-no">088</span><span id="line-88"> *      D3 D3 D1 D0   E3 E2 E2 E0   F3 F2 F1 F0</span>
<span class="source-line-no">089</span><span id="line-89"> *</span>
<span class="source-line-no">090</span><span id="line-90"> *   Bytes split into groups by order-of-magnitude:</span>
<span class="source-line-no">091</span><span id="line-91"> *      A3 B3 C3   A2 B2 C2   A1 B1 C1   A0 B0 C0</span>
<span class="source-line-no">092</span><span id="line-92"> *      D3 E3 F3   D2 E2 F2   D1 E1 F1   D0 E0 F0</span>
<span class="source-line-no">093</span><span id="line-93"> * &lt;/pre&gt;</span>
<span class="source-line-no">094</span><span id="line-94"> *</span>
<span class="source-line-no">095</span><span id="line-95"> * To further improve the compression, the predictor takes the difference of each subsequent bytes. Again, the differences (deltas) are computed on a</span>
<span class="source-line-no">096</span><span id="line-96"> * row-byte-row basis. For the most part, the differences combine bytes associated with the same order-of-magnitude, though there is a special transition at the</span>
<span class="source-line-no">097</span><span id="line-97"> * end of each order-of-magnitude set (shown in parentheses):</span>
<span class="source-line-no">098</span><span id="line-98"> *</span>
<span class="source-line-no">099</span><span id="line-99"> * &lt;pre&gt;</span>
<span class="source-line-no">100</span><span id="line-100"> *      A3, B3-A3, C3-B3, (A2-C3), B2-A2, C2-B2, (A1-C2), etc.</span>
<span class="source-line-no">101</span><span id="line-101"> *      D3, E3-D3, F3-D3, (D2-F3), E3-D2, etc.</span>
<span class="source-line-no">102</span><span id="line-102"> * &lt;/pre&gt;</span>
<span class="source-line-no">103</span><span id="line-103"> *</span>
<span class="source-line-no">104</span><span id="line-104"> * Once the predictor transform is complete, the data is stored using conventional data compression techniques such as Deflate or LZW. In practice, floating</span>
<span class="source-line-no">105</span><span id="line-105"> * point data does not compress especially well, but using the above technique, the TIFF process typically reduces the overall storage size by 20 to 30 percent</span>
<span class="source-line-no">106</span><span id="line-106"> * (depending on the data). The TIFF Technical Note 3 specifies 3 data size formats for storing floating point values:</span>
<span class="source-line-no">107</span><span id="line-107"> *</span>
<span class="source-line-no">108</span><span id="line-108"> * &lt;pre&gt;</span>
<span class="source-line-no">109</span><span id="line-109"> *     32 bits    IEEE-754 single-precision standard</span>
<span class="source-line-no">110</span><span id="line-110"> *     16 bits    IEEE-754 half-precision standard</span>
<span class="source-line-no">111</span><span id="line-111"> *     24 bits    A non-standard representation</span>
<span class="source-line-no">112</span><span id="line-112"> * &lt;/pre&gt;</span>
<span class="source-line-no">113</span><span id="line-113"> *</span>
<span class="source-line-no">114</span><span id="line-114"> * At this time, we have not obtained data samples for the smaller representations used in combination with a predictor.</span>
<span class="source-line-no">115</span><span id="line-115"> * &lt;p&gt;</span>
<span class="source-line-no">116</span><span id="line-116"> * &lt;strong&gt;Interleaved formats&lt;/strong&gt;</span>
<span class="source-line-no">117</span><span id="line-117"> * &lt;p&gt;</span>
<span class="source-line-no">118</span><span id="line-118"> * TIFF Technical Note 3 also provides example code for cases where each pixel (or raster cell) in the image is associated with more than one floating-point</span>
<span class="source-line-no">119</span><span id="line-119"> * samples. Data in this format might be used for real-valued vector data, complex-valued pairs, or other numerical applications).</span>
<span class="source-line-no">120</span><span id="line-120"> * &lt;p&gt;</span>
<span class="source-line-no">121</span><span id="line-121"> * At this time, we have encountered only a limited selection of the possible configurations for multi-variable data. The code below only supports those</span>
<span class="source-line-no">122</span><span id="line-122"> * configurations for which we had actual images that could be used to verify our implementation. The implementation supports the following formats:</span>
<span class="source-line-no">123</span><span id="line-123"> * &lt;ul&gt;</span>
<span class="source-line-no">124</span><span id="line-124"> * &lt;li&gt;32-bit floating-point data&lt;/li&gt;</span>
<span class="source-line-no">125</span><span id="line-125"> * &lt;li&gt;Uncompressed, Deflate, or LZW compression&lt;/li&gt;</span>
<span class="source-line-no">126</span><span id="line-126"> * &lt;li&gt;Optional horizontal predictors used with compression&lt;/li&gt;</span>
<span class="source-line-no">127</span><span id="line-127"> * &lt;li&gt;PlanarConfiguration interleaved (CHUNKY) or non-interleaved (PLANAR)&lt;/li&gt;</span>
<span class="source-line-no">128</span><span id="line-128"> * &lt;/ul&gt;</span>
<span class="source-line-no">129</span><span id="line-129"> * &lt;p&gt;</span>
<span class="source-line-no">130</span><span id="line-130"> * Note that integer formats are not supported at this time.</span>
<span class="source-line-no">131</span><span id="line-131"> * &lt;p&gt;</span>
<span class="source-line-no">132</span><span id="line-132"> * Often, the TIFF files store multi-variable data in so that samples are interleaved. For example, a configuration that gave two samples per pixel (or cell)</span>
<span class="source-line-no">133</span><span id="line-133"> * would give the two values for the first pixel in order followed by the two values for the second pixel, etc. If a differencing approach were used for data</span>
<span class="source-line-no">134</span><span id="line-134"> * compression, the byte-stream would begin with the high-order byte for each of the two samples for the first pixel, followed by the high-order byte for each</span>
<span class="source-line-no">135</span><span id="line-135"> * of the next two samples, and so forth for the remainder of the row of pixels. It would then follow with the second-highest-order bytes for the first two</span>
<span class="source-line-no">136</span><span id="line-136"> * samples, etc.</span>
<span class="source-line-no">137</span><span id="line-137"> * &lt;p&gt;</span>
<span class="source-line-no">138</span><span id="line-138"> * This implementation also supports the non-interleaved (PLANAR) configuration. One consideration in implementing this feature was that TIFF Technical Note 3</span>
<span class="source-line-no">139</span><span id="line-139"> * does not address the case where a TIFF image uses the alternate planar configuration. For conventional images, the TIFF specification (Revision 6.0)</span>
<span class="source-line-no">140</span><span id="line-140"> * recommends that the planar configuration should be avoided (see pg. 38). But for numerical data products, the planar configuration may yield better data</span>
<span class="source-line-no">141</span><span id="line-141"> * compression in the case where different sample sets have different statistical properties. Because separated groups often have more uniformity and</span>
<span class="source-line-no">142</span><span id="line-142"> * predictability than interleaved data sets, they sometimes lead to a small improvement in storage-size reduction when data compression is used.</span>
<span class="source-line-no">143</span><span id="line-143"> */</span>
<span class="source-line-no">144</span><span id="line-144">public abstract class ImageDataReader {</span>
<span class="source-line-no">145</span><span id="line-145"></span>
<span class="source-line-no">146</span><span id="line-146">    protected final TiffDirectory directory;</span>
<span class="source-line-no">147</span><span id="line-147">    protected final PhotometricInterpreter photometricInterpreter;</span>
<span class="source-line-no">148</span><span id="line-148">    private final int[] bitsPerSample;</span>
<span class="source-line-no">149</span><span id="line-149">    protected final int bitsPerSampleLength;</span>
<span class="source-line-no">150</span><span id="line-150">    private final int[] last;</span>
<span class="source-line-no">151</span><span id="line-151"></span>
<span class="source-line-no">152</span><span id="line-152">    protected final int predictor;</span>
<span class="source-line-no">153</span><span id="line-153">    protected final int samplesPerPixel;</span>
<span class="source-line-no">154</span><span id="line-154">    protected final int width;</span>
<span class="source-line-no">155</span><span id="line-155">    protected final int height;</span>
<span class="source-line-no">156</span><span id="line-156">    protected final int sampleFormat;</span>
<span class="source-line-no">157</span><span id="line-157"></span>
<span class="source-line-no">158</span><span id="line-158">    protected final TiffPlanarConfiguration planarConfiguration;</span>
<span class="source-line-no">159</span><span id="line-159"></span>
<span class="source-line-no">160</span><span id="line-160">    public ImageDataReader(final TiffDirectory directory, final PhotometricInterpreter photometricInterpreter, final int[] bitsPerSample, final int predictor,</span>
<span class="source-line-no">161</span><span id="line-161">            final int samplesPerPixel, final int sampleFormat, final int width, final int height, final TiffPlanarConfiguration planarConfiguration) {</span>
<span class="source-line-no">162</span><span id="line-162">        this.directory = directory;</span>
<span class="source-line-no">163</span><span id="line-163">        this.photometricInterpreter = photometricInterpreter;</span>
<span class="source-line-no">164</span><span id="line-164">        this.bitsPerSample = bitsPerSample;</span>
<span class="source-line-no">165</span><span id="line-165">        this.bitsPerSampleLength = bitsPerSample.length;</span>
<span class="source-line-no">166</span><span id="line-166">        this.samplesPerPixel = samplesPerPixel;</span>
<span class="source-line-no">167</span><span id="line-167">        this.sampleFormat = sampleFormat;</span>
<span class="source-line-no">168</span><span id="line-168">        this.predictor = predictor;</span>
<span class="source-line-no">169</span><span id="line-169">        this.width = width;</span>
<span class="source-line-no">170</span><span id="line-170">        this.height = height;</span>
<span class="source-line-no">171</span><span id="line-171">        this.planarConfiguration = planarConfiguration;</span>
<span class="source-line-no">172</span><span id="line-172">        last = Allocator.intArray(samplesPerPixel);</span>
<span class="source-line-no">173</span><span id="line-173"></span>
<span class="source-line-no">174</span><span id="line-174">    }</span>
<span class="source-line-no">175</span><span id="line-175"></span>
<span class="source-line-no">176</span><span id="line-176">    protected int[] applyPredictor(final int[] samples) {</span>
<span class="source-line-no">177</span><span id="line-177">        if (predictor == 2) {</span>
<span class="source-line-no">178</span><span id="line-178">            // Horizontal differencing.</span>
<span class="source-line-no">179</span><span id="line-179">            for (int i = 0; i &lt; samples.length; i++) {</span>
<span class="source-line-no">180</span><span id="line-180">                samples[i] = 0xff &amp; samples[i] + last[i];</span>
<span class="source-line-no">181</span><span id="line-181">                last[i] = samples[i];</span>
<span class="source-line-no">182</span><span id="line-182">            }</span>
<span class="source-line-no">183</span><span id="line-183">        }</span>
<span class="source-line-no">184</span><span id="line-184"></span>
<span class="source-line-no">185</span><span id="line-185">        return samples;</span>
<span class="source-line-no">186</span><span id="line-186">    }</span>
<span class="source-line-no">187</span><span id="line-187"></span>
<span class="source-line-no">188</span><span id="line-188">    protected void applyPredictorToBlock(final int width, final int height, final int nSamplesPerPixel, final byte[] p) {</span>
<span class="source-line-no">189</span><span id="line-189">        final int k = width * nSamplesPerPixel;</span>
<span class="source-line-no">190</span><span id="line-190">        for (int i = 0; i &lt; height; i++) {</span>
<span class="source-line-no">191</span><span id="line-191">            final int j0 = i * k + nSamplesPerPixel;</span>
<span class="source-line-no">192</span><span id="line-192">            final int j1 = (i + 1) * k;</span>
<span class="source-line-no">193</span><span id="line-193">            for (int j = j0; j &lt; j1; j++) {</span>
<span class="source-line-no">194</span><span id="line-194">                p[j] += p[j - nSamplesPerPixel];</span>
<span class="source-line-no">195</span><span id="line-195">            }</span>
<span class="source-line-no">196</span><span id="line-196">        }</span>
<span class="source-line-no">197</span><span id="line-197">    }</span>
<span class="source-line-no">198</span><span id="line-198"></span>
<span class="source-line-no">199</span><span id="line-199">    protected byte[] decompress(final byte[] compressedInput, final int compression, final int expectedSize, final int tileWidth, final int tileHeight)</span>
<span class="source-line-no">200</span><span id="line-200">            throws ImagingException, IOException {</span>
<span class="source-line-no">201</span><span id="line-201">        final TiffField fillOrderField = directory.findField(TiffTagConstants.TIFF_TAG_FILL_ORDER);</span>
<span class="source-line-no">202</span><span id="line-202">        int fillOrder = TiffTagConstants.FILL_ORDER_VALUE_NORMAL;</span>
<span class="source-line-no">203</span><span id="line-203">        if (fillOrderField != null) {</span>
<span class="source-line-no">204</span><span id="line-204">            fillOrder = fillOrderField.getIntValue();</span>
<span class="source-line-no">205</span><span id="line-205">        }</span>
<span class="source-line-no">206</span><span id="line-206">        final byte[] compressedOrdered; // re-ordered bytes (if necessary)</span>
<span class="source-line-no">207</span><span id="line-207">        if (fillOrder == TiffTagConstants.FILL_ORDER_VALUE_NORMAL) {</span>
<span class="source-line-no">208</span><span id="line-208">            compressedOrdered = compressedInput;</span>
<span class="source-line-no">209</span><span id="line-209">            // good</span>
<span class="source-line-no">210</span><span id="line-210">        } else if (fillOrder == TiffTagConstants.FILL_ORDER_VALUE_REVERSED) {</span>
<span class="source-line-no">211</span><span id="line-211">            compressedOrdered = new byte[compressedInput.length];</span>
<span class="source-line-no">212</span><span id="line-212">            for (int i = 0; i &lt; compressedInput.length; i++) {</span>
<span class="source-line-no">213</span><span id="line-213">                compressedOrdered[i] = (byte) (Integer.reverse(0xff &amp; compressedInput[i]) &gt;&gt;&gt; 24);</span>
<span class="source-line-no">214</span><span id="line-214">            }</span>
<span class="source-line-no">215</span><span id="line-215">        } else {</span>
<span class="source-line-no">216</span><span id="line-216">            throw new ImagingException("TIFF FillOrder=" + fillOrder + " is invalid");</span>
<span class="source-line-no">217</span><span id="line-217">        }</span>
<span class="source-line-no">218</span><span id="line-218"></span>
<span class="source-line-no">219</span><span id="line-219">        switch (compression) {</span>
<span class="source-line-no">220</span><span id="line-220">        case TIFF_COMPRESSION_UNCOMPRESSED:</span>
<span class="source-line-no">221</span><span id="line-221">            // None;</span>
<span class="source-line-no">222</span><span id="line-222">            return compressedOrdered;</span>
<span class="source-line-no">223</span><span id="line-223">        case TIFF_COMPRESSION_CCITT_1D:</span>
<span class="source-line-no">224</span><span id="line-224">            // CCITT Group 3 1-Dimensional Modified Huffman run-length encoding.</span>
<span class="source-line-no">225</span><span id="line-225">            return T4AndT6Compression.decompressModifiedHuffman(compressedOrdered, tileWidth, tileHeight);</span>
<span class="source-line-no">226</span><span id="line-226">        case TIFF_COMPRESSION_CCITT_GROUP_3: {</span>
<span class="source-line-no">227</span><span id="line-227">            int t4Options = 0;</span>
<span class="source-line-no">228</span><span id="line-228">            final TiffField field = directory.findField(TiffTagConstants.TIFF_TAG_T4_OPTIONS);</span>
<span class="source-line-no">229</span><span id="line-229">            if (field != null) {</span>
<span class="source-line-no">230</span><span id="line-230">                t4Options = field.getIntValue();</span>
<span class="source-line-no">231</span><span id="line-231">            }</span>
<span class="source-line-no">232</span><span id="line-232">            final boolean is2D = (t4Options &amp; TIFF_FLAG_T4_OPTIONS_2D) != 0;</span>
<span class="source-line-no">233</span><span id="line-233">            final boolean usesUncompressedMode = (t4Options &amp; TIFF_FLAG_T4_OPTIONS_UNCOMPRESSED_MODE) != 0;</span>
<span class="source-line-no">234</span><span id="line-234">            if (usesUncompressedMode) {</span>
<span class="source-line-no">235</span><span id="line-235">                throw new ImagingException("T.4 compression with the uncompressed mode extension is not yet supported");</span>
<span class="source-line-no">236</span><span id="line-236">            }</span>
<span class="source-line-no">237</span><span id="line-237">            final boolean hasFillBitsBeforeEOL = (t4Options &amp; TIFF_FLAG_T4_OPTIONS_FILL) != 0;</span>
<span class="source-line-no">238</span><span id="line-238">            if (is2D) {</span>
<span class="source-line-no">239</span><span id="line-239">                return T4AndT6Compression.decompressT4_2D(compressedOrdered, tileWidth, tileHeight, hasFillBitsBeforeEOL);</span>
<span class="source-line-no">240</span><span id="line-240">            }</span>
<span class="source-line-no">241</span><span id="line-241">            return T4AndT6Compression.decompressT4_1D(compressedOrdered, tileWidth, tileHeight, hasFillBitsBeforeEOL);</span>
<span class="source-line-no">242</span><span id="line-242">        }</span>
<span class="source-line-no">243</span><span id="line-243">        case TIFF_COMPRESSION_CCITT_GROUP_4: {</span>
<span class="source-line-no">244</span><span id="line-244">            int t6Options = 0;</span>
<span class="source-line-no">245</span><span id="line-245">            final TiffField field = directory.findField(TiffTagConstants.TIFF_TAG_T6_OPTIONS);</span>
<span class="source-line-no">246</span><span id="line-246">            if (field != null) {</span>
<span class="source-line-no">247</span><span id="line-247">                t6Options = field.getIntValue();</span>
<span class="source-line-no">248</span><span id="line-248">            }</span>
<span class="source-line-no">249</span><span id="line-249">            final boolean usesUncompressedMode = (t6Options &amp; TIFF_FLAG_T6_OPTIONS_UNCOMPRESSED_MODE) != 0;</span>
<span class="source-line-no">250</span><span id="line-250">            if (usesUncompressedMode) {</span>
<span class="source-line-no">251</span><span id="line-251">                throw new ImagingException("T.6 compression with the uncompressed mode extension is not yet supported");</span>
<span class="source-line-no">252</span><span id="line-252">            }</span>
<span class="source-line-no">253</span><span id="line-253">            return T4AndT6Compression.decompressT6(compressedOrdered, tileWidth, tileHeight);</span>
<span class="source-line-no">254</span><span id="line-254">        }</span>
<span class="source-line-no">255</span><span id="line-255">        case TIFF_COMPRESSION_LZW: {</span>
<span class="source-line-no">256</span><span id="line-256">            final InputStream is = new ByteArrayInputStream(compressedOrdered);</span>
<span class="source-line-no">257</span><span id="line-257">            final int lzwMinimumCodeSize = 8;</span>
<span class="source-line-no">258</span><span id="line-258">            return new MyLzwDecompressor(lzwMinimumCodeSize, ByteOrder.BIG_ENDIAN, true).decompress(is, expectedSize);</span>
<span class="source-line-no">259</span><span id="line-259">        }</span>
<span class="source-line-no">260</span><span id="line-260"></span>
<span class="source-line-no">261</span><span id="line-261">        // Packbits</span>
<span class="source-line-no">262</span><span id="line-262">        case TIFF_COMPRESSION_PACKBITS: {</span>
<span class="source-line-no">263</span><span id="line-263">            return PackBits.decompress(compressedOrdered, expectedSize);</span>
<span class="source-line-no">264</span><span id="line-264">        }</span>
<span class="source-line-no">265</span><span id="line-265"></span>
<span class="source-line-no">266</span><span id="line-266">        // deflate</span>
<span class="source-line-no">267</span><span id="line-267">        case TIFF_COMPRESSION_DEFLATE_ADOBE:</span>
<span class="source-line-no">268</span><span id="line-268">        case TIFF_COMPRESSION_DEFLATE_PKZIP: {</span>
<span class="source-line-no">269</span><span id="line-269">            return ZlibDeflate.decompress(compressedInput, expectedSize);</span>
<span class="source-line-no">270</span><span id="line-270">        }</span>
<span class="source-line-no">271</span><span id="line-271"></span>
<span class="source-line-no">272</span><span id="line-272">        default:</span>
<span class="source-line-no">273</span><span id="line-273">            throw new ImagingException("Tiff: unknown/unsupported compression: " + compression);</span>
<span class="source-line-no">274</span><span id="line-274">        }</span>
<span class="source-line-no">275</span><span id="line-275">    }</span>
<span class="source-line-no">276</span><span id="line-276"></span>
<span class="source-line-no">277</span><span id="line-277">    /**</span>
<span class="source-line-no">278</span><span id="line-278">     * Reads samples and returns them in an int array.</span>
<span class="source-line-no">279</span><span id="line-279">     *</span>
<span class="source-line-no">280</span><span id="line-280">     * @param bis    the stream to read from</span>
<span class="source-line-no">281</span><span id="line-281">     * @param result the samples array to populate, must be the same length as bitsPerSample.length</span>
<span class="source-line-no">282</span><span id="line-282">     * @throws IOException</span>
<span class="source-line-no">283</span><span id="line-283">     */</span>
<span class="source-line-no">284</span><span id="line-284">    void getSamplesAsBytes(final BitInputStream bis, final int[] result) throws IOException {</span>
<span class="source-line-no">285</span><span id="line-285">        for (int i = 0; i &lt; bitsPerSample.length; i++) {</span>
<span class="source-line-no">286</span><span id="line-286">            final int bits = bitsPerSample[i];</span>
<span class="source-line-no">287</span><span id="line-287">            int sample = bis.readBits(bits);</span>
<span class="source-line-no">288</span><span id="line-288">            if (bits &lt; 8) {</span>
<span class="source-line-no">289</span><span id="line-289">                final int sign = sample &amp; 1;</span>
<span class="source-line-no">290</span><span id="line-290">                sample = sample &lt;&lt; 8 - bits; // scale to byte.</span>
<span class="source-line-no">291</span><span id="line-291">                if (sign &gt; 0) {</span>
<span class="source-line-no">292</span><span id="line-292">                    sample = sample | (1 &lt;&lt; 8 - bits) - 1; // extend to byte</span>
<span class="source-line-no">293</span><span id="line-293">                }</span>
<span class="source-line-no">294</span><span id="line-294">            } else if (bits &gt; 8) {</span>
<span class="source-line-no">295</span><span id="line-295">                sample = sample &gt;&gt; bits - 8; // extend to byte.</span>
<span class="source-line-no">296</span><span id="line-296">            }</span>
<span class="source-line-no">297</span><span id="line-297">            result[i] = sample;</span>
<span class="source-line-no">298</span><span id="line-298">        }</span>
<span class="source-line-no">299</span><span id="line-299">    }</span>
<span class="source-line-no">300</span><span id="line-300"></span>
<span class="source-line-no">301</span><span id="line-301">    /**</span>
<span class="source-line-no">302</span><span id="line-302">     * Checks if all the bits per sample entries are the same size</span>
<span class="source-line-no">303</span><span id="line-303">     *</span>
<span class="source-line-no">304</span><span id="line-304">     * @param size the size to check</span>
<span class="source-line-no">305</span><span id="line-305">     * @return true if all the bits per sample entries are the same</span>
<span class="source-line-no">306</span><span id="line-306">     */</span>
<span class="source-line-no">307</span><span id="line-307">    protected boolean isHomogenous(final int size) {</span>
<span class="source-line-no">308</span><span id="line-308">        for (final int element : bitsPerSample) {</span>
<span class="source-line-no">309</span><span id="line-309">            if (element != size) {</span>
<span class="source-line-no">310</span><span id="line-310">                return false;</span>
<span class="source-line-no">311</span><span id="line-311">            }</span>
<span class="source-line-no">312</span><span id="line-312">        }</span>
<span class="source-line-no">313</span><span id="line-313">        return true;</span>
<span class="source-line-no">314</span><span id="line-314">    }</span>
<span class="source-line-no">315</span><span id="line-315"></span>
<span class="source-line-no">316</span><span id="line-316">    /**</span>
<span class="source-line-no">317</span><span id="line-317">     * Read the image data from the IFD associated with this instance of ImageDataReader using the optional sub-image specification if desired.</span>
<span class="source-line-no">318</span><span id="line-318">     *</span>
<span class="source-line-no">319</span><span id="line-319">     * @param subImageSpecification a rectangle describing a sub-region of the image for reading, or a null if the whole image is to be read.</span>
<span class="source-line-no">320</span><span id="line-320">     * @param hasAlpha              indicates that the image has an alpha (transparency) channel (RGB color model only).</span>
<span class="source-line-no">321</span><span id="line-321">     * @param isAlphaPremultiplied  indicates that the image uses the associated alpha channel format (pre-multiplied alpha).</span>
<span class="source-line-no">322</span><span id="line-322">     * @return a valid instance containing the pixel data from the image.</span>
<span class="source-line-no">323</span><span id="line-323">     * @throws IOException      in the event of an unrecoverable I/O error.</span>
<span class="source-line-no">324</span><span id="line-324">     * @throws ImagingException TODO</span>
<span class="source-line-no">325</span><span id="line-325">     */</span>
<span class="source-line-no">326</span><span id="line-326">    public abstract ImageBuilder readImageData(Rectangle subImageSpecification, boolean hasAlpha, boolean isAlphaPremultiplied)</span>
<span class="source-line-no">327</span><span id="line-327">            throws IOException, ImagingException;</span>
<span class="source-line-no">328</span><span id="line-328"></span>
<span class="source-line-no">329</span><span id="line-329">    /**</span>
<span class="source-line-no">330</span><span id="line-330">     * Defines a method for accessing the floating-point raster data in a TIFF image. These implementations of this method in DataReaderStrips and</span>
<span class="source-line-no">331</span><span id="line-331">     * DataReaderTiled assume that this instance is of a compatible data type (floating-point) and that all access checks have already been performed.</span>
<span class="source-line-no">332</span><span id="line-332">     *</span>
<span class="source-line-no">333</span><span id="line-333">     * @param subImage if non-null, instructs the access method to retrieve only a sub-section of the image data.</span>
<span class="source-line-no">334</span><span id="line-334">     * @return a valid instance</span>
<span class="source-line-no">335</span><span id="line-335">     * @throws ImagingException in the event of an incompatible data form.</span>
<span class="source-line-no">336</span><span id="line-336">     * @throws IOException      in the event of I/O error.</span>
<span class="source-line-no">337</span><span id="line-337">     */</span>
<span class="source-line-no">338</span><span id="line-338">    public abstract TiffRasterData readRasterData(Rectangle subImage) throws ImagingException, IOException;</span>
<span class="source-line-no">339</span><span id="line-339"></span>
<span class="source-line-no">340</span><span id="line-340">    protected void resetPredictor() {</span>
<span class="source-line-no">341</span><span id="line-341">        Arrays.fill(last, 0);</span>
<span class="source-line-no">342</span><span id="line-342">    }</span>
<span class="source-line-no">343</span><span id="line-343"></span>
<span class="source-line-no">344</span><span id="line-344">    /**</span>
<span class="source-line-no">345</span><span id="line-345">     * Transfer samples obtained from the TIFF file to a floating-point raster.</span>
<span class="source-line-no">346</span><span id="line-346">     *</span>
<span class="source-line-no">347</span><span id="line-347">     * @param xBlock       coordinate of block relative to source data</span>
<span class="source-line-no">348</span><span id="line-348">     * @param yBlock       coordinate of block relative to source data</span>
<span class="source-line-no">349</span><span id="line-349">     * @param blockWidth   width of block, in pixels</span>
<span class="source-line-no">350</span><span id="line-350">     * @param blockHeight  height of block in pixels</span>
<span class="source-line-no">351</span><span id="line-351">     * @param blockData    the data for the block</span>
<span class="source-line-no">352</span><span id="line-352">     * @param xRaster      coordinate of raster relative to source data</span>
<span class="source-line-no">353</span><span id="line-353">     * @param yRaster      coordinate of raster relative to source data</span>
<span class="source-line-no">354</span><span id="line-354">     * @param rasterWidth  width of the raster (always smaller than source data)</span>
<span class="source-line-no">355</span><span id="line-355">     * @param rasterHeight height of the raster (always smaller than source data)</span>
<span class="source-line-no">356</span><span id="line-356">     * @param rasterData   the raster data.</span>
<span class="source-line-no">357</span><span id="line-357">     */</span>
<span class="source-line-no">358</span><span id="line-358">    void transferBlockToRaster(final int xBlock, final int yBlock, final int blockWidth, final int blockHeight, final int[] blockData, final int xRaster,</span>
<span class="source-line-no">359</span><span id="line-359">            final int yRaster, final int rasterWidth, final int rasterHeight, final int samplesPerPixel, final float[] rasterData) {</span>
<span class="source-line-no">360</span><span id="line-360"></span>
<span class="source-line-no">361</span><span id="line-361">        // xR0, yR0 are the coordinates within the raster (upper-left corner)</span>
<span class="source-line-no">362</span><span id="line-362">        // xR1, yR1 are ONE PAST the coordinates of the lower-right corner</span>
<span class="source-line-no">363</span><span id="line-363">        int xR0 = xBlock - xRaster; // xR0, yR0 coordinates relative to</span>
<span class="source-line-no">364</span><span id="line-364">        int yR0 = yBlock - yRaster; // the raster</span>
<span class="source-line-no">365</span><span id="line-365">        int xR1 = xR0 + blockWidth;</span>
<span class="source-line-no">366</span><span id="line-366">        int yR1 = yR0 + blockHeight;</span>
<span class="source-line-no">367</span><span id="line-367">        if (xR0 &lt; 0) {</span>
<span class="source-line-no">368</span><span id="line-368">            xR0 = 0;</span>
<span class="source-line-no">369</span><span id="line-369">        }</span>
<span class="source-line-no">370</span><span id="line-370">        if (yR0 &lt; 0) {</span>
<span class="source-line-no">371</span><span id="line-371">            yR0 = 0;</span>
<span class="source-line-no">372</span><span id="line-372">        }</span>
<span class="source-line-no">373</span><span id="line-373">        if (xR1 &gt; rasterWidth) {</span>
<span class="source-line-no">374</span><span id="line-374">            xR1 = rasterWidth;</span>
<span class="source-line-no">375</span><span id="line-375">        }</span>
<span class="source-line-no">376</span><span id="line-376">        if (yR1 &gt; rasterHeight) {</span>
<span class="source-line-no">377</span><span id="line-377">            yR1 = rasterHeight;</span>
<span class="source-line-no">378</span><span id="line-378">        }</span>
<span class="source-line-no">379</span><span id="line-379"></span>
<span class="source-line-no">380</span><span id="line-380">        // Recall that the above logic may have adjusted xR0, xY0 so that</span>
<span class="source-line-no">381</span><span id="line-381">        // they are not necessarily point to the source pixel at xRaster, yRaster</span>
<span class="source-line-no">382</span><span id="line-382">        // we compute xSource = xR0+xRaster.</span>
<span class="source-line-no">383</span><span id="line-383">        // xOffset = xSource-xBlock</span>
<span class="source-line-no">384</span><span id="line-384">        // since the block cannot be accessed with a negative offset,</span>
<span class="source-line-no">385</span><span id="line-385">        // we check for negatives and adjust xR0, yR0 upward as necessary</span>
<span class="source-line-no">386</span><span id="line-386">        int xB0 = xR0 + xRaster - xBlock;</span>
<span class="source-line-no">387</span><span id="line-387">        int yB0 = yR0 + yRaster - yBlock;</span>
<span class="source-line-no">388</span><span id="line-388">        if (xB0 &lt; 0) {</span>
<span class="source-line-no">389</span><span id="line-389">            xR0 -= xB0;</span>
<span class="source-line-no">390</span><span id="line-390">            xB0 = 0;</span>
<span class="source-line-no">391</span><span id="line-391">        }</span>
<span class="source-line-no">392</span><span id="line-392">        if (yB0 &lt; 0) {</span>
<span class="source-line-no">393</span><span id="line-393">            yR0 -= yB0;</span>
<span class="source-line-no">394</span><span id="line-394">            yB0 = 0;</span>
<span class="source-line-no">395</span><span id="line-395">        }</span>
<span class="source-line-no">396</span><span id="line-396"></span>
<span class="source-line-no">397</span><span id="line-397">        int w = xR1 - xR0;</span>
<span class="source-line-no">398</span><span id="line-398">        int h = yR1 - yR0;</span>
<span class="source-line-no">399</span><span id="line-399">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="source-line-no">400</span><span id="line-400">            // The call to this method put the block outside the</span>
<span class="source-line-no">401</span><span id="line-401">            // bounds of the raster. There is nothing to do. Ideally,</span>
<span class="source-line-no">402</span><span id="line-402">            // this situation never arises, because it would mean that</span>
<span class="source-line-no">403</span><span id="line-403">            // the data was read from the file unnecessarily.</span>
<span class="source-line-no">404</span><span id="line-404">            return;</span>
<span class="source-line-no">405</span><span id="line-405">        }</span>
<span class="source-line-no">406</span><span id="line-406">        // see if the xR1, yR1 would extend past the limits of the block</span>
<span class="source-line-no">407</span><span id="line-407">        if (w &gt; blockWidth) {</span>
<span class="source-line-no">408</span><span id="line-408">            w = blockWidth;</span>
<span class="source-line-no">409</span><span id="line-409">        }</span>
<span class="source-line-no">410</span><span id="line-410">        if (h &gt; blockHeight) {</span>
<span class="source-line-no">411</span><span id="line-411">            h = blockHeight;</span>
<span class="source-line-no">412</span><span id="line-412">        }</span>
<span class="source-line-no">413</span><span id="line-413"></span>
<span class="source-line-no">414</span><span id="line-414">        // The TiffRasterData class expects data to be in the order</span>
<span class="source-line-no">415</span><span id="line-415">        // corresponding to TiffPlanarConfiguration.PLANAR. So for the</span>
<span class="source-line-no">416</span><span id="line-416">        // multivariable case, we must convert CHUNKY data to PLANAR.</span>
<span class="source-line-no">417</span><span id="line-417">        if (samplesPerPixel == 1) {</span>
<span class="source-line-no">418</span><span id="line-418">            for (int i = 0; i &lt; h; i++) {</span>
<span class="source-line-no">419</span><span id="line-419">                final int yR = yR0 + i;</span>
<span class="source-line-no">420</span><span id="line-420">                final int yB = yB0 + i;</span>
<span class="source-line-no">421</span><span id="line-421">                final int rOffset = yR * rasterWidth + xR0;</span>
<span class="source-line-no">422</span><span id="line-422">                final int bOffset = yB * blockWidth + xB0;</span>
<span class="source-line-no">423</span><span id="line-423">                for (int j = 0; j &lt; w; j++) {</span>
<span class="source-line-no">424</span><span id="line-424">                    rasterData[rOffset + j] = Float.intBitsToFloat(blockData[bOffset + j]);</span>
<span class="source-line-no">425</span><span id="line-425">                }</span>
<span class="source-line-no">426</span><span id="line-426">            }</span>
<span class="source-line-no">427</span><span id="line-427">        } else if (this.planarConfiguration == TiffPlanarConfiguration.CHUNKY) {</span>
<span class="source-line-no">428</span><span id="line-428">            // The source data is in the interleaved (Chunky) order,</span>
<span class="source-line-no">429</span><span id="line-429">            // but the TiffRasterData class expects non-interleaved order.</span>
<span class="source-line-no">430</span><span id="line-430">            // So we transcribe the elements as appropriate.</span>
<span class="source-line-no">431</span><span id="line-431">            final int pixelsPerPlane = rasterWidth * rasterHeight;</span>
<span class="source-line-no">432</span><span id="line-432">            for (int i = 0; i &lt; h; i++) {</span>
<span class="source-line-no">433</span><span id="line-433">                final int yR = yR0 + i;</span>
<span class="source-line-no">434</span><span id="line-434">                final int yB = yB0 + i;</span>
<span class="source-line-no">435</span><span id="line-435">                final int rOffset = yR * rasterWidth + xR0;</span>
<span class="source-line-no">436</span><span id="line-436">                final int bOffset = yB * blockWidth + xB0;</span>
<span class="source-line-no">437</span><span id="line-437">                for (int j = 0; j &lt; w; j++) {</span>
<span class="source-line-no">438</span><span id="line-438">                    for (int k = 0; k &lt; samplesPerPixel; k++) {</span>
<span class="source-line-no">439</span><span id="line-439">                        rasterData[k * pixelsPerPlane + rOffset + j] = Float.intBitsToFloat(blockData[(bOffset + j) * samplesPerPixel + k]);</span>
<span class="source-line-no">440</span><span id="line-440">                    }</span>
<span class="source-line-no">441</span><span id="line-441">                }</span>
<span class="source-line-no">442</span><span id="line-442">            }</span>
<span class="source-line-no">443</span><span id="line-443">        } else {</span>
<span class="source-line-no">444</span><span id="line-444">            for (int iPlane = 0; iPlane &lt; samplesPerPixel; iPlane++) {</span>
<span class="source-line-no">445</span><span id="line-445">                final int rPlanarOffset = iPlane * rasterWidth * rasterHeight;</span>
<span class="source-line-no">446</span><span id="line-446">                final int bPlanarOffset = iPlane * blockWidth * blockHeight;</span>
<span class="source-line-no">447</span><span id="line-447">                for (int i = 0; i &lt; h; i++) {</span>
<span class="source-line-no">448</span><span id="line-448">                    final int yR = yR0 + i;</span>
<span class="source-line-no">449</span><span id="line-449">                    final int yB = yB0 + i;</span>
<span class="source-line-no">450</span><span id="line-450">                    final int rOffset = rPlanarOffset + yR * rasterWidth + xR0;</span>
<span class="source-line-no">451</span><span id="line-451">                    final int bOffset = bPlanarOffset + yB * blockWidth + xB0;</span>
<span class="source-line-no">452</span><span id="line-452">                    for (int j = 0; j &lt; w; j++) {</span>
<span class="source-line-no">453</span><span id="line-453">                        rasterData[rOffset + j] = Float.intBitsToFloat(blockData[bOffset + j]);</span>
<span class="source-line-no">454</span><span id="line-454">                    }</span>
<span class="source-line-no">455</span><span id="line-455">                }</span>
<span class="source-line-no">456</span><span id="line-456">            }</span>
<span class="source-line-no">457</span><span id="line-457">        }</span>
<span class="source-line-no">458</span><span id="line-458"></span>
<span class="source-line-no">459</span><span id="line-459">    }</span>
<span class="source-line-no">460</span><span id="line-460"></span>
<span class="source-line-no">461</span><span id="line-461">    /**</span>
<span class="source-line-no">462</span><span id="line-462">     * Transfer samples obtained from the TIFF file to an integer raster.</span>
<span class="source-line-no">463</span><span id="line-463">     *</span>
<span class="source-line-no">464</span><span id="line-464">     * @param xBlock       coordinate of block relative to source data</span>
<span class="source-line-no">465</span><span id="line-465">     * @param yBlock       coordinate of block relative to source data</span>
<span class="source-line-no">466</span><span id="line-466">     * @param blockWidth   width of block, in pixels</span>
<span class="source-line-no">467</span><span id="line-467">     * @param blockHeight  height of block in pixels</span>
<span class="source-line-no">468</span><span id="line-468">     * @param blockData    the data for the block</span>
<span class="source-line-no">469</span><span id="line-469">     * @param xRaster      coordinate of raster relative to source data</span>
<span class="source-line-no">470</span><span id="line-470">     * @param yRaster      coordinate of raster relative to source data</span>
<span class="source-line-no">471</span><span id="line-471">     * @param rasterWidth  width of the raster (always smaller than source data)</span>
<span class="source-line-no">472</span><span id="line-472">     * @param rasterHeight height of the raster (always smaller than source data)</span>
<span class="source-line-no">473</span><span id="line-473">     * @param rasterData   the raster data.</span>
<span class="source-line-no">474</span><span id="line-474">     */</span>
<span class="source-line-no">475</span><span id="line-475">    void transferBlockToRaster(final int xBlock, final int yBlock, final int blockWidth, final int blockHeight, final int[] blockData, final int xRaster,</span>
<span class="source-line-no">476</span><span id="line-476">            final int yRaster, final int rasterWidth, final int rasterHeight, final int[] rasterData) {</span>
<span class="source-line-no">477</span><span id="line-477"></span>
<span class="source-line-no">478</span><span id="line-478">        // xR0, yR0 are the coordinates within the raster (upper-left corner)</span>
<span class="source-line-no">479</span><span id="line-479">        // xR1, yR1 are ONE PAST the coordinates of the lower-right corner</span>
<span class="source-line-no">480</span><span id="line-480">        int xR0 = xBlock - xRaster; // xR0, yR0 coordinates relative to</span>
<span class="source-line-no">481</span><span id="line-481">        int yR0 = yBlock - yRaster; // the raster</span>
<span class="source-line-no">482</span><span id="line-482">        int xR1 = xR0 + blockWidth;</span>
<span class="source-line-no">483</span><span id="line-483">        int yR1 = yR0 + blockHeight;</span>
<span class="source-line-no">484</span><span id="line-484">        if (xR0 &lt; 0) {</span>
<span class="source-line-no">485</span><span id="line-485">            xR0 = 0;</span>
<span class="source-line-no">486</span><span id="line-486">        }</span>
<span class="source-line-no">487</span><span id="line-487">        if (yR0 &lt; 0) {</span>
<span class="source-line-no">488</span><span id="line-488">            yR0 = 0;</span>
<span class="source-line-no">489</span><span id="line-489">        }</span>
<span class="source-line-no">490</span><span id="line-490">        if (xR1 &gt; rasterWidth) {</span>
<span class="source-line-no">491</span><span id="line-491">            xR1 = rasterWidth;</span>
<span class="source-line-no">492</span><span id="line-492">        }</span>
<span class="source-line-no">493</span><span id="line-493">        if (yR1 &gt; rasterHeight) {</span>
<span class="source-line-no">494</span><span id="line-494">            yR1 = rasterHeight;</span>
<span class="source-line-no">495</span><span id="line-495">        }</span>
<span class="source-line-no">496</span><span id="line-496"></span>
<span class="source-line-no">497</span><span id="line-497">        // Recall that the above logic may have adjusted xR0, xY0 so that</span>
<span class="source-line-no">498</span><span id="line-498">        // they are not necessarily point to the source pixel at xRaster, yRaster</span>
<span class="source-line-no">499</span><span id="line-499">        // we compute xSource = xR0+xRaster.</span>
<span class="source-line-no">500</span><span id="line-500">        // xOffset = xSource-xBlock</span>
<span class="source-line-no">501</span><span id="line-501">        // since the block cannot be accessed with a negative offset,</span>
<span class="source-line-no">502</span><span id="line-502">        // we check for negatives and adjust xR0, yR0 upward as necessary</span>
<span class="source-line-no">503</span><span id="line-503">        int xB0 = xR0 + xRaster - xBlock;</span>
<span class="source-line-no">504</span><span id="line-504">        int yB0 = yR0 + yRaster - yBlock;</span>
<span class="source-line-no">505</span><span id="line-505">        if (xB0 &lt; 0) {</span>
<span class="source-line-no">506</span><span id="line-506">            xR0 -= xB0;</span>
<span class="source-line-no">507</span><span id="line-507">            xB0 = 0;</span>
<span class="source-line-no">508</span><span id="line-508">        }</span>
<span class="source-line-no">509</span><span id="line-509">        if (yB0 &lt; 0) {</span>
<span class="source-line-no">510</span><span id="line-510">            yR0 -= yB0;</span>
<span class="source-line-no">511</span><span id="line-511">            yB0 = 0;</span>
<span class="source-line-no">512</span><span id="line-512">        }</span>
<span class="source-line-no">513</span><span id="line-513"></span>
<span class="source-line-no">514</span><span id="line-514">        int w = xR1 - xR0;</span>
<span class="source-line-no">515</span><span id="line-515">        int h = yR1 - yR0;</span>
<span class="source-line-no">516</span><span id="line-516">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="source-line-no">517</span><span id="line-517">            // The call to this method puts the block outside the</span>
<span class="source-line-no">518</span><span id="line-518">            // bounds of the raster. There is nothing to do. Ideally,</span>
<span class="source-line-no">519</span><span id="line-519">            // this situation never arises, because it would mean that</span>
<span class="source-line-no">520</span><span id="line-520">            // the data was read from the file unnecessarily.</span>
<span class="source-line-no">521</span><span id="line-521">            return;</span>
<span class="source-line-no">522</span><span id="line-522">        }</span>
<span class="source-line-no">523</span><span id="line-523">        // see if the xR1, yR1 would extend past the limits of the block</span>
<span class="source-line-no">524</span><span id="line-524">        if (w &gt; blockWidth) {</span>
<span class="source-line-no">525</span><span id="line-525">            w = blockWidth;</span>
<span class="source-line-no">526</span><span id="line-526">        }</span>
<span class="source-line-no">527</span><span id="line-527">        if (h &gt; blockHeight) {</span>
<span class="source-line-no">528</span><span id="line-528">            h = blockHeight;</span>
<span class="source-line-no">529</span><span id="line-529">        }</span>
<span class="source-line-no">530</span><span id="line-530"></span>
<span class="source-line-no">531</span><span id="line-531">        for (int i = 0; i &lt; h; i++) {</span>
<span class="source-line-no">532</span><span id="line-532">            final int yR = yR0 + i;</span>
<span class="source-line-no">533</span><span id="line-533">            final int yB = yB0 + i;</span>
<span class="source-line-no">534</span><span id="line-534">            final int rOffset = yR * rasterWidth + xR0;</span>
<span class="source-line-no">535</span><span id="line-535">            final int bOffset = yB * blockWidth + xB0;</span>
<span class="source-line-no">536</span><span id="line-536">            System.arraycopy(blockData, bOffset, rasterData, rOffset, w);</span>
<span class="source-line-no">537</span><span id="line-537">        }</span>
<span class="source-line-no">538</span><span id="line-538">    }</span>
<span class="source-line-no">539</span><span id="line-539"></span>
<span class="source-line-no">540</span><span id="line-540">    /**</span>
<span class="source-line-no">541</span><span id="line-541">     * Given a source file that specifies the floating-point data format, unpack the raw bytes obtained from the source file and organize them into an array of</span>
<span class="source-line-no">542</span><span id="line-542">     * integers containing the bit-equivalent of IEEE-754 32-bit floats. Source files containing 64 bit doubles are downcast to floats.</span>
<span class="source-line-no">543</span><span id="line-543">     * &lt;p&gt;</span>
<span class="source-line-no">544</span><span id="line-544">     * This method supports either the tile format or the strip format of TIFF source files. The scan size indicates the number of columns to be extracted. For</span>
<span class="source-line-no">545</span><span id="line-545">     * strips, the width and the scan size are always the full width of the image. For tiles, the scan size is the full width of the tile, but the width may be</span>
<span class="source-line-no">546</span><span id="line-546">     * smaller in the cases where the tiles do not evenly divide the width (for example, a 256 pixel wide tile in a 257 pixel wide image would result in two</span>
<span class="source-line-no">547</span><span id="line-547">     * columns of tiles, the second column having only one column of pixels that were worth extracting.</span>
<span class="source-line-no">548</span><span id="line-548">     *</span>
<span class="source-line-no">549</span><span id="line-549">     * @param width        the width of the data block to be extracted</span>
<span class="source-line-no">550</span><span id="line-550">     * @param height       the height of the data block to be extracted</span>
<span class="source-line-no">551</span><span id="line-551">     * @param scanSize     the number of pixels in a single row of the block</span>
<span class="source-line-no">552</span><span id="line-552">     * @param bytes        the raw bytes</span>
<span class="source-line-no">553</span><span id="line-553">     * @param bitsPerPixel the number of bits per sample, 32 or 64.</span>
<span class="source-line-no">554</span><span id="line-554">     * @param byteOrder    the byte order for the source data</span>
<span class="source-line-no">555</span><span id="line-555">     * @return a valid array of integers in row major order, dimensions scan-size wide and height.</span>
<span class="source-line-no">556</span><span id="line-556">     * @throws ImagingException in the event of an invalid format.</span>
<span class="source-line-no">557</span><span id="line-557">     */</span>
<span class="source-line-no">558</span><span id="line-558">    protected int[] unpackFloatingPointSamples(final int width, final int height, final int scanSize, final byte[] bytes, final int bitsPerPixel,</span>
<span class="source-line-no">559</span><span id="line-559">            final ByteOrder byteOrder) throws ImagingException {</span>
<span class="source-line-no">560</span><span id="line-560">        final int bitsPerSample = bitsPerPixel / samplesPerPixel;</span>
<span class="source-line-no">561</span><span id="line-561">        final int bytesPerSample = bitsPerSample / 8;</span>
<span class="source-line-no">562</span><span id="line-562">        final int bytesPerScan = scanSize * samplesPerPixel * bytesPerSample;</span>
<span class="source-line-no">563</span><span id="line-563">        final int nBytes = bytesPerScan * height;</span>
<span class="source-line-no">564</span><span id="line-564">        final int length = bytes.length &lt; nBytes ? nBytes / bytesPerScan : height;</span>
<span class="source-line-no">565</span><span id="line-565">        final int[] samples = Allocator.intArray(scanSize * samplesPerPixel * height);</span>
<span class="source-line-no">566</span><span id="line-566">        // floating-point differencing is indicated by a predictor value of 3.</span>
<span class="source-line-no">567</span><span id="line-567">        if (predictor == TiffTagConstants.PREDICTOR_VALUE_FLOATING_POINT_DIFFERENCING) {</span>
<span class="source-line-no">568</span><span id="line-568">            // at this time, this class supports the 32-bit format. The</span>
<span class="source-line-no">569</span><span id="line-569">            // main reason for this is that we have not located sample data</span>
<span class="source-line-no">570</span><span id="line-570">            // that can be used for testing and analysis.</span>
<span class="source-line-no">571</span><span id="line-571">            if (bitsPerPixel / samplesPerPixel != 32) {</span>
<span class="source-line-no">572</span><span id="line-572">                throw new ImagingException(</span>
<span class="source-line-no">573</span><span id="line-573">                        "Imaging does not yet support floating-point data" + " with predictor type 3 for " + bitsPerPixel + " bits per sample");</span>
<span class="source-line-no">574</span><span id="line-574">            }</span>
<span class="source-line-no">575</span><span id="line-575"></span>
<span class="source-line-no">576</span><span id="line-576">            if (planarConfiguration == TiffPlanarConfiguration.CHUNKY) {</span>
<span class="source-line-no">577</span><span id="line-577">                final int bytesInRow = scanSize * 4 * samplesPerPixel;</span>
<span class="source-line-no">578</span><span id="line-578">                for (int i = 0; i &lt; length; i++) {</span>
<span class="source-line-no">579</span><span id="line-579">                    final int aOffset = i * bytesInRow;</span>
<span class="source-line-no">580</span><span id="line-580">                    final int bOffset = aOffset + scanSize * samplesPerPixel;</span>
<span class="source-line-no">581</span><span id="line-581">                    final int cOffset = bOffset + scanSize * samplesPerPixel;</span>
<span class="source-line-no">582</span><span id="line-582">                    final int dOffset = cOffset + scanSize * samplesPerPixel;</span>
<span class="source-line-no">583</span><span id="line-583">                    // in this loop, the source bytes give delta values.</span>
<span class="source-line-no">584</span><span id="line-584">                    // we adjust them to give true values. This operation is</span>
<span class="source-line-no">585</span><span id="line-585">                    // done on a row-by-row basis.</span>
<span class="source-line-no">586</span><span id="line-586">                    for (int j = 1; j &lt; bytesInRow; j++) {</span>
<span class="source-line-no">587</span><span id="line-587">                        bytes[aOffset + j] += bytes[aOffset + j - 1];</span>
<span class="source-line-no">588</span><span id="line-588">                    }</span>
<span class="source-line-no">589</span><span id="line-589">                    // pack the bytes into the integer bit-equivalent of</span>
<span class="source-line-no">590</span><span id="line-590">                    // floating point values</span>
<span class="source-line-no">591</span><span id="line-591">                    int index = i * scanSize;</span>
<span class="source-line-no">592</span><span id="line-592">                    for (int j = 0; j &lt; width * samplesPerPixel; j++) {</span>
<span class="source-line-no">593</span><span id="line-593">                        final int a = bytes[aOffset + j];</span>
<span class="source-line-no">594</span><span id="line-594">                        final int b = bytes[bOffset + j];</span>
<span class="source-line-no">595</span><span id="line-595">                        final int c = bytes[cOffset + j];</span>
<span class="source-line-no">596</span><span id="line-596">                        final int d = bytes[dOffset + j];</span>
<span class="source-line-no">597</span><span id="line-597">                        // Pack the 4 byte components into a single integer</span>
<span class="source-line-no">598</span><span id="line-598">                        // in the byte order used by the TIFF standard</span>
<span class="source-line-no">599</span><span id="line-599">                        samples[index++] = (a &amp; 0xff) &lt;&lt; 24 | (b &amp; 0xff) &lt;&lt; 16 | (c &amp; 0xff) &lt;&lt; 8 | d &amp; 0xff;</span>
<span class="source-line-no">600</span><span id="line-600">                    }</span>
<span class="source-line-no">601</span><span id="line-601">                }</span>
<span class="source-line-no">602</span><span id="line-602">            } else {</span>
<span class="source-line-no">603</span><span id="line-603">                final int bytesInRow = scanSize * 4;</span>
<span class="source-line-no">604</span><span id="line-604">                for (int iPlane = 0; iPlane &lt; samplesPerPixel; iPlane++) {</span>
<span class="source-line-no">605</span><span id="line-605">                    final int planarIntOffset = iPlane * length * scanSize;</span>
<span class="source-line-no">606</span><span id="line-606">                    final int planarByteOffset = planarIntOffset * 4;</span>
<span class="source-line-no">607</span><span id="line-607"></span>
<span class="source-line-no">608</span><span id="line-608">                    for (int i = 0; i &lt; length; i++) {</span>
<span class="source-line-no">609</span><span id="line-609">                        final int aOffset = i * bytesInRow + planarByteOffset;</span>
<span class="source-line-no">610</span><span id="line-610">                        final int bOffset = aOffset + scanSize;</span>
<span class="source-line-no">611</span><span id="line-611">                        final int cOffset = bOffset + scanSize;</span>
<span class="source-line-no">612</span><span id="line-612">                        final int dOffset = cOffset + scanSize;</span>
<span class="source-line-no">613</span><span id="line-613">                        // in this loop, the source bytes give delta values.</span>
<span class="source-line-no">614</span><span id="line-614">                        // we adjust them to give true values. This operation is</span>
<span class="source-line-no">615</span><span id="line-615">                        // done on a row-by-row basis.</span>
<span class="source-line-no">616</span><span id="line-616">                        for (int j = 1; j &lt; bytesInRow; j++) {</span>
<span class="source-line-no">617</span><span id="line-617">                            bytes[aOffset + j] += bytes[aOffset + j - 1];</span>
<span class="source-line-no">618</span><span id="line-618">                        }</span>
<span class="source-line-no">619</span><span id="line-619">                        // pack the bytes into the integer bit-equivalent of</span>
<span class="source-line-no">620</span><span id="line-620">                        // floating point values</span>
<span class="source-line-no">621</span><span id="line-621">                        int index = planarIntOffset + i * scanSize;</span>
<span class="source-line-no">622</span><span id="line-622">                        for (int j = 0; j &lt; width; j++) {</span>
<span class="source-line-no">623</span><span id="line-623">                            final int a = bytes[aOffset + j];</span>
<span class="source-line-no">624</span><span id="line-624">                            final int b = bytes[bOffset + j];</span>
<span class="source-line-no">625</span><span id="line-625">                            final int c = bytes[cOffset + j];</span>
<span class="source-line-no">626</span><span id="line-626">                            final int d = bytes[dOffset + j];</span>
<span class="source-line-no">627</span><span id="line-627">                            // Pack the 4 byte components into a single integer</span>
<span class="source-line-no">628</span><span id="line-628">                            // in the byte order used by the TIFF standard</span>
<span class="source-line-no">629</span><span id="line-629">                            samples[index++] = (a &amp; 0xff) &lt;&lt; 24 | (b &amp; 0xff) &lt;&lt; 16 | (c &amp; 0xff) &lt;&lt; 8 | d &amp; 0xff;</span>
<span class="source-line-no">630</span><span id="line-630">                        }</span>
<span class="source-line-no">631</span><span id="line-631">                    }</span>
<span class="source-line-no">632</span><span id="line-632">                }</span>
<span class="source-line-no">633</span><span id="line-633"></span>
<span class="source-line-no">634</span><span id="line-634">            }</span>
<span class="source-line-no">635</span><span id="line-635">            return samples;</span>
<span class="source-line-no">636</span><span id="line-636">        } // end of predictor==3 case.</span>
<span class="source-line-no">637</span><span id="line-637"></span>
<span class="source-line-no">638</span><span id="line-638">        // simple packing case, 64 or 32 bits --------------------------</span>
<span class="source-line-no">639</span><span id="line-639">        if (bitsPerSample == 64) {</span>
<span class="source-line-no">640</span><span id="line-640">            int k = 0;</span>
<span class="source-line-no">641</span><span id="line-641">            int index = 0;</span>
<span class="source-line-no">642</span><span id="line-642">            for (int i = 0; i &lt; length; i++) {</span>
<span class="source-line-no">643</span><span id="line-643">                for (int j = 0; j &lt; scanSize; j++) {</span>
<span class="source-line-no">644</span><span id="line-644">                    final long b0 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">645</span><span id="line-645">                    final long b1 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">646</span><span id="line-646">                    final long b2 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">647</span><span id="line-647">                    final long b3 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">648</span><span id="line-648">                    final long b4 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">649</span><span id="line-649">                    final long b5 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">650</span><span id="line-650">                    final long b6 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">651</span><span id="line-651">                    final long b7 = bytes[k++] &amp; 0xffL;</span>
<span class="source-line-no">652</span><span id="line-652">                    long sbits;</span>
<span class="source-line-no">653</span><span id="line-653">                    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {</span>
<span class="source-line-no">654</span><span id="line-654">                        sbits = b7 &lt;&lt; 56 | b6 &lt;&lt; 48 | b5 &lt;&lt; 40 | b4 &lt;&lt; 32 | b3 &lt;&lt; 24 | b2 &lt;&lt; 16 | b1 &lt;&lt; 8 | b0;</span>
<span class="source-line-no">655</span><span id="line-655"></span>
<span class="source-line-no">656</span><span id="line-656">                    } else {</span>
<span class="source-line-no">657</span><span id="line-657">                        sbits = b0 &lt;&lt; 56 | b1 &lt;&lt; 48 | b2 &lt;&lt; 40 | b3 &lt;&lt; 32 | b4 &lt;&lt; 24 | b5 &lt;&lt; 16 | b6 &lt;&lt; 8 | b7;</span>
<span class="source-line-no">658</span><span id="line-658">                    }</span>
<span class="source-line-no">659</span><span id="line-659">                    // since the photometric interpreter does not</span>
<span class="source-line-no">660</span><span id="line-660">                    // currently support doubles, we need to replace this</span>
<span class="source-line-no">661</span><span id="line-661">                    // element with a float. This action is inefficient and</span>
<span class="source-line-no">662</span><span id="line-662">                    // should be improved.</span>
<span class="source-line-no">663</span><span id="line-663">                    final float f = (float) Double.longBitsToDouble(sbits);</span>
<span class="source-line-no">664</span><span id="line-664">                    samples[index++] = Float.floatToRawIntBits(f);</span>
<span class="source-line-no">665</span><span id="line-665">                }</span>
<span class="source-line-no">666</span><span id="line-666">            }</span>
<span class="source-line-no">667</span><span id="line-667">        } else if (bitsPerSample == 32) {</span>
<span class="source-line-no">668</span><span id="line-668">            int k = 0;</span>
<span class="source-line-no">669</span><span id="line-669">            int index = 0;</span>
<span class="source-line-no">670</span><span id="line-670">            for (int i = 0; i &lt; length; i++) {</span>
<span class="source-line-no">671</span><span id="line-671">                for (int j = 0; j &lt; scanSize * samplesPerPixel; j++) {</span>
<span class="source-line-no">672</span><span id="line-672">                    final int b0 = bytes[k++] &amp; 0xff;</span>
<span class="source-line-no">673</span><span id="line-673">                    final int b1 = bytes[k++] &amp; 0xff;</span>
<span class="source-line-no">674</span><span id="line-674">                    final int b2 = bytes[k++] &amp; 0xff;</span>
<span class="source-line-no">675</span><span id="line-675">                    final int b3 = bytes[k++] &amp; 0xff;</span>
<span class="source-line-no">676</span><span id="line-676">                    int sbits;</span>
<span class="source-line-no">677</span><span id="line-677">                    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {</span>
<span class="source-line-no">678</span><span id="line-678">                        sbits = b3 &lt;&lt; 24 | b2 &lt;&lt; 16 | b1 &lt;&lt; 8 | b0;</span>
<span class="source-line-no">679</span><span id="line-679"></span>
<span class="source-line-no">680</span><span id="line-680">                    } else {</span>
<span class="source-line-no">681</span><span id="line-681">                        sbits = b0 &lt;&lt; 24 | b1 &lt;&lt; 16 | b2 &lt;&lt; 8 | b3;</span>
<span class="source-line-no">682</span><span id="line-682">                    }</span>
<span class="source-line-no">683</span><span id="line-683">                    // since the photometric interpreter does not</span>
<span class="source-line-no">684</span><span id="line-684">                    // currently support doubles, we need to replace this</span>
<span class="source-line-no">685</span><span id="line-685">                    // element with a float. This action is inefficient and</span>
<span class="source-line-no">686</span><span id="line-686">                    // should be improved.</span>
<span class="source-line-no">687</span><span id="line-687">                    samples[index++] = sbits;</span>
<span class="source-line-no">688</span><span id="line-688">                }</span>
<span class="source-line-no">689</span><span id="line-689">            }</span>
<span class="source-line-no">690</span><span id="line-690">        } else {</span>
<span class="source-line-no">691</span><span id="line-691">            throw new ImagingException("Imaging does not support floating-point samples with " + bitsPerPixel + " bits per sample");</span>
<span class="source-line-no">692</span><span id="line-692">        }</span>
<span class="source-line-no">693</span><span id="line-693"></span>
<span class="source-line-no">694</span><span id="line-694">        return samples;</span>
<span class="source-line-no">695</span><span id="line-695">    }</span>
<span class="source-line-no">696</span><span id="line-696"></span>
<span class="source-line-no">697</span><span id="line-697">    /**</span>
<span class="source-line-no">698</span><span id="line-698">     * Given a source file that specifies numerical data as short integers, unpack the raw bytes obtained from the source file and organize them into an array</span>
<span class="source-line-no">699</span><span id="line-699">     * of integers.</span>
<span class="source-line-no">700</span><span id="line-700">     * &lt;p&gt;</span>
<span class="source-line-no">701</span><span id="line-701">     * This method supports either the tile format or the strip format of TIFF source files. The scan size indicates the number of columns to be extracted. For</span>
<span class="source-line-no">702</span><span id="line-702">     * strips, the width and the scan size are always the full width of the image. For tiles, the scan size is the full width of the tile, but the "width"</span>
<span class="source-line-no">703</span><span id="line-703">     * parameter may be smaller in the cases where the tiles do not evenly divide the width (for example, a 256 pixel wide tile in a 257 pixel wide image would</span>
<span class="source-line-no">704</span><span id="line-704">     * result in two columns of tiles, the second column having only one column of pixels that were worth extracting.</span>
<span class="source-line-no">705</span><span id="line-705">     *</span>
<span class="source-line-no">706</span><span id="line-706">     * @param width         the width of the data block to be extracted</span>
<span class="source-line-no">707</span><span id="line-707">     * @param height        the height of the data block to be extracted</span>
<span class="source-line-no">708</span><span id="line-708">     * @param scanSize      the number of pixels in a single row of the block</span>
<span class="source-line-no">709</span><span id="line-709">     * @param bytes         the raw bytes</span>
<span class="source-line-no">710</span><span id="line-710">     * @param predictor     the predictor specified by the source, only predictor 3 is supported.</span>
<span class="source-line-no">711</span><span id="line-711">     * @param bitsPerSample the number of bits per sample, 32 or 64.</span>
<span class="source-line-no">712</span><span id="line-712">     * @param byteOrder     the byte order for the source data</span>
<span class="source-line-no">713</span><span id="line-713">     * @return a valid array of integers in row major order, dimensions scan-size wide and height.</span>
<span class="source-line-no">714</span><span id="line-714">     */</span>
<span class="source-line-no">715</span><span id="line-715">    protected int[] unpackIntSamples(final int width, final int height, final int scanSize, final byte[] bytes, final int predictor, final int bitsPerSample,</span>
<span class="source-line-no">716</span><span id="line-716">            final ByteOrder byteOrder) {</span>
<span class="source-line-no">717</span><span id="line-717">        final int bytesPerSample = bitsPerSample / 8;</span>
<span class="source-line-no">718</span><span id="line-718">        final int nBytes = bytesPerSample * scanSize * height;</span>
<span class="source-line-no">719</span><span id="line-719">        final int length = bytes.length &lt; nBytes ? nBytes / scanSize : height;</span>
<span class="source-line-no">720</span><span id="line-720"></span>
<span class="source-line-no">721</span><span id="line-721">        final int[] samples = Allocator.intArray(scanSize * height);</span>
<span class="source-line-no">722</span><span id="line-722">        // At this time, Commons Imaging only supports two-byte</span>
<span class="source-line-no">723</span><span id="line-723">        // two's complement short integers. It is assumed that</span>
<span class="source-line-no">724</span><span id="line-724">        // the calling module already checked the arguments for</span>
<span class="source-line-no">725</span><span id="line-725">        // compliance, so this method simply assumes that they are correct.</span>
<span class="source-line-no">726</span><span id="line-726"></span>
<span class="source-line-no">727</span><span id="line-727">        // The logic that follows is simplified by the fact that</span>
<span class="source-line-no">728</span><span id="line-728">        // the existing API only supports two-byte signed integers.</span>
<span class="source-line-no">729</span><span id="line-729">        final boolean useDifferencing = predictor == TiffTagConstants.PREDICTOR_VALUE_HORIZONTAL_DIFFERENCING;</span>
<span class="source-line-no">730</span><span id="line-730"></span>
<span class="source-line-no">731</span><span id="line-731">        for (int i = 0; i &lt; length; i++) {</span>
<span class="source-line-no">732</span><span id="line-732">            final int index = i * scanSize;</span>
<span class="source-line-no">733</span><span id="line-733">            int offset = index * bytesPerSample;</span>
<span class="source-line-no">734</span><span id="line-734">            if (bitsPerSample == 16) {</span>
<span class="source-line-no">735</span><span id="line-735">                if (byteOrder == ByteOrder.LITTLE_ENDIAN) {</span>
<span class="source-line-no">736</span><span id="line-736">                    for (int j = 0; j &lt; width; j++, offset += 2) {</span>
<span class="source-line-no">737</span><span id="line-737">                        samples[index + j] = bytes[offset + 1] &lt;&lt; 8 | bytes[offset] &amp; 0xff;</span>
<span class="source-line-no">738</span><span id="line-738">                    }</span>
<span class="source-line-no">739</span><span id="line-739">                } else {</span>
<span class="source-line-no">740</span><span id="line-740">                    for (int j = 0; j &lt; width; j++, offset += 2) {</span>
<span class="source-line-no">741</span><span id="line-741">                        samples[index + j] = bytes[offset] &lt;&lt; 8 | bytes[offset + 1] &amp; 0xff;</span>
<span class="source-line-no">742</span><span id="line-742">                    }</span>
<span class="source-line-no">743</span><span id="line-743">                }</span>
<span class="source-line-no">744</span><span id="line-744">            } else if (bitsPerSample == 32) {</span>
<span class="source-line-no">745</span><span id="line-745">                if (byteOrder == ByteOrder.LITTLE_ENDIAN) {</span>
<span class="source-line-no">746</span><span id="line-746">                    for (int j = 0; j &lt; width; j++, offset += 4) {</span>
<span class="source-line-no">747</span><span id="line-747">                        samples[index + j] = bytes[offset + 3] &lt;&lt; 24 | (bytes[offset + 2] &amp; 0xff) &lt;&lt; 16 | (bytes[offset + 1] &amp; 0xff) &lt;&lt; 8</span>
<span class="source-line-no">748</span><span id="line-748">                                | bytes[offset] &amp; 0xff;</span>
<span class="source-line-no">749</span><span id="line-749">                    }</span>
<span class="source-line-no">750</span><span id="line-750">                } else {</span>
<span class="source-line-no">751</span><span id="line-751">                    for (int j = 0; j &lt; width; j++, offset += 4) {</span>
<span class="source-line-no">752</span><span id="line-752">                        samples[index + j] = bytes[offset] &lt;&lt; 24 | (bytes[offset + 1] &amp; 0xff) &lt;&lt; 16 | (bytes[offset + 2] &amp; 0xff) &lt;&lt; 8</span>
<span class="source-line-no">753</span><span id="line-753">                                | bytes[offset + 3] &amp; 0xff;</span>
<span class="source-line-no">754</span><span id="line-754">                    }</span>
<span class="source-line-no">755</span><span id="line-755">                }</span>
<span class="source-line-no">756</span><span id="line-756">            }</span>
<span class="source-line-no">757</span><span id="line-757">            if (useDifferencing) {</span>
<span class="source-line-no">758</span><span id="line-758">                for (int j = 1; j &lt; width; j++) {</span>
<span class="source-line-no">759</span><span id="line-759">                    samples[index + j] += samples[index + j - 1];</span>
<span class="source-line-no">760</span><span id="line-760">                }</span>
<span class="source-line-no">761</span><span id="line-761">            }</span>
<span class="source-line-no">762</span><span id="line-762">        }</span>
<span class="source-line-no">763</span><span id="line-763"></span>
<span class="source-line-no">764</span><span id="line-764">        return samples;</span>
<span class="source-line-no">765</span><span id="line-765">    }</span>
<span class="source-line-no">766</span><span id="line-766">}</span>




























































</pre>
</div>
</main>
</body>
</html>
